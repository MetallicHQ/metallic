// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: agent.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientUnaryCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "agent";

export interface HealthCheckRequest {
}

export interface HealthCheckResponse {
  success: boolean;
  error: string;
}

export interface MetricsRequest {
}

export interface MetricsResponse {
  success: boolean;
  cpuCount: number;
  cpuUsedPct: number;
  memTotalMiB: number;
  memUsedMiB: number;
  gpu?: string | undefined;
  vramTotalMiB?: number | undefined;
  vramUsedMiB?: number | undefined;
  timestamp: string;
  error: string;
}

export interface GetHostRequest {
  projectId: string;
  instanceId: string;
  port: number;
}

export interface GetHostResponse {
  success: boolean;
  host: string;
  error: string;
}

function createBaseHealthCheckRequest(): HealthCheckRequest {
  return {};
}

export const HealthCheckRequest: MessageFns<HealthCheckRequest> = {
  encode(_: HealthCheckRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): HealthCheckRequest {
    return {};
  },

  toJSON(_: HealthCheckRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(base?: I): HealthCheckRequest {
    return HealthCheckRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckRequest>, I>>(_: I): HealthCheckRequest {
    const message = createBaseHealthCheckRequest();
    return message;
  },
};

function createBaseHealthCheckResponse(): HealthCheckResponse {
  return { success: false, error: "" };
}

export const HealthCheckResponse: MessageFns<HealthCheckResponse> = {
  encode(message: HealthCheckResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): HealthCheckResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseHealthCheckResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): HealthCheckResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: HealthCheckResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(base?: I): HealthCheckResponse {
    return HealthCheckResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<HealthCheckResponse>, I>>(object: I): HealthCheckResponse {
    const message = createBaseHealthCheckResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseMetricsRequest(): MetricsRequest {
  return {};
}

export const MetricsRequest: MessageFns<MetricsRequest> = {
  encode(_: MetricsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(_: any): MetricsRequest {
    return {};
  },

  toJSON(_: MetricsRequest): unknown {
    const obj: any = {};
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsRequest>, I>>(base?: I): MetricsRequest {
    return MetricsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsRequest>, I>>(_: I): MetricsRequest {
    const message = createBaseMetricsRequest();
    return message;
  },
};

function createBaseMetricsResponse(): MetricsResponse {
  return {
    success: false,
    cpuCount: 0,
    cpuUsedPct: 0,
    memTotalMiB: 0,
    memUsedMiB: 0,
    gpu: undefined,
    vramTotalMiB: undefined,
    vramUsedMiB: undefined,
    timestamp: "",
    error: "",
  };
}

export const MetricsResponse: MessageFns<MetricsResponse> = {
  encode(message: MetricsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.cpuCount !== 0) {
      writer.uint32(16).int32(message.cpuCount);
    }
    if (message.cpuUsedPct !== 0) {
      writer.uint32(25).double(message.cpuUsedPct);
    }
    if (message.memTotalMiB !== 0) {
      writer.uint32(32).int32(message.memTotalMiB);
    }
    if (message.memUsedMiB !== 0) {
      writer.uint32(40).int32(message.memUsedMiB);
    }
    if (message.gpu !== undefined) {
      writer.uint32(50).string(message.gpu);
    }
    if (message.vramTotalMiB !== undefined) {
      writer.uint32(56).int32(message.vramTotalMiB);
    }
    if (message.vramUsedMiB !== undefined) {
      writer.uint32(64).int32(message.vramUsedMiB);
    }
    if (message.timestamp !== "") {
      writer.uint32(74).string(message.timestamp);
    }
    if (message.error !== "") {
      writer.uint32(82).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): MetricsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseMetricsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.cpuCount = reader.int32();
          continue;
        }
        case 3: {
          if (tag !== 25) {
            break;
          }

          message.cpuUsedPct = reader.double();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.memTotalMiB = reader.int32();
          continue;
        }
        case 5: {
          if (tag !== 40) {
            break;
          }

          message.memUsedMiB = reader.int32();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.gpu = reader.string();
          continue;
        }
        case 7: {
          if (tag !== 56) {
            break;
          }

          message.vramTotalMiB = reader.int32();
          continue;
        }
        case 8: {
          if (tag !== 64) {
            break;
          }

          message.vramUsedMiB = reader.int32();
          continue;
        }
        case 9: {
          if (tag !== 74) {
            break;
          }

          message.timestamp = reader.string();
          continue;
        }
        case 10: {
          if (tag !== 82) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): MetricsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      cpuCount: isSet(object.cpuCount) ? globalThis.Number(object.cpuCount) : 0,
      cpuUsedPct: isSet(object.cpuUsedPct) ? globalThis.Number(object.cpuUsedPct) : 0,
      memTotalMiB: isSet(object.memTotalMiB) ? globalThis.Number(object.memTotalMiB) : 0,
      memUsedMiB: isSet(object.memUsedMiB) ? globalThis.Number(object.memUsedMiB) : 0,
      gpu: isSet(object.gpu) ? globalThis.String(object.gpu) : undefined,
      vramTotalMiB: isSet(object.vramTotalMiB) ? globalThis.Number(object.vramTotalMiB) : undefined,
      vramUsedMiB: isSet(object.vramUsedMiB) ? globalThis.Number(object.vramUsedMiB) : undefined,
      timestamp: isSet(object.timestamp) ? globalThis.String(object.timestamp) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: MetricsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.cpuCount !== 0) {
      obj.cpuCount = Math.round(message.cpuCount);
    }
    if (message.cpuUsedPct !== 0) {
      obj.cpuUsedPct = message.cpuUsedPct;
    }
    if (message.memTotalMiB !== 0) {
      obj.memTotalMiB = Math.round(message.memTotalMiB);
    }
    if (message.memUsedMiB !== 0) {
      obj.memUsedMiB = Math.round(message.memUsedMiB);
    }
    if (message.gpu !== undefined) {
      obj.gpu = message.gpu;
    }
    if (message.vramTotalMiB !== undefined) {
      obj.vramTotalMiB = Math.round(message.vramTotalMiB);
    }
    if (message.vramUsedMiB !== undefined) {
      obj.vramUsedMiB = Math.round(message.vramUsedMiB);
    }
    if (message.timestamp !== "") {
      obj.timestamp = message.timestamp;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<MetricsResponse>, I>>(base?: I): MetricsResponse {
    return MetricsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<MetricsResponse>, I>>(object: I): MetricsResponse {
    const message = createBaseMetricsResponse();
    message.success = object.success ?? false;
    message.cpuCount = object.cpuCount ?? 0;
    message.cpuUsedPct = object.cpuUsedPct ?? 0;
    message.memTotalMiB = object.memTotalMiB ?? 0;
    message.memUsedMiB = object.memUsedMiB ?? 0;
    message.gpu = object.gpu ?? undefined;
    message.vramTotalMiB = object.vramTotalMiB ?? undefined;
    message.vramUsedMiB = object.vramUsedMiB ?? undefined;
    message.timestamp = object.timestamp ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetHostRequest(): GetHostRequest {
  return { projectId: "", instanceId: "", port: 0 };
}

export const GetHostRequest: MessageFns<GetHostRequest> = {
  encode(message: GetHostRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.projectId !== "") {
      writer.uint32(10).string(message.projectId);
    }
    if (message.instanceId !== "") {
      writer.uint32(18).string(message.instanceId);
    }
    if (message.port !== 0) {
      writer.uint32(24).int32(message.port);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHostRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHostRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.projectId = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.instanceId = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.port = reader.int32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHostRequest {
    return {
      projectId: isSet(object.projectId) ? globalThis.String(object.projectId) : "",
      instanceId: isSet(object.instanceId) ? globalThis.String(object.instanceId) : "",
      port: isSet(object.port) ? globalThis.Number(object.port) : 0,
    };
  },

  toJSON(message: GetHostRequest): unknown {
    const obj: any = {};
    if (message.projectId !== "") {
      obj.projectId = message.projectId;
    }
    if (message.instanceId !== "") {
      obj.instanceId = message.instanceId;
    }
    if (message.port !== 0) {
      obj.port = Math.round(message.port);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHostRequest>, I>>(base?: I): GetHostRequest {
    return GetHostRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHostRequest>, I>>(object: I): GetHostRequest {
    const message = createBaseGetHostRequest();
    message.projectId = object.projectId ?? "";
    message.instanceId = object.instanceId ?? "";
    message.port = object.port ?? 0;
    return message;
  },
};

function createBaseGetHostResponse(): GetHostResponse {
  return { success: false, host: "", error: "" };
}

export const GetHostResponse: MessageFns<GetHostResponse> = {
  encode(message: GetHostResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.host !== "") {
      writer.uint32(18).string(message.host);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetHostResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetHostResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.host = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetHostResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      host: isSet(object.host) ? globalThis.String(object.host) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetHostResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.host !== "") {
      obj.host = message.host;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetHostResponse>, I>>(base?: I): GetHostResponse {
    return GetHostResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetHostResponse>, I>>(object: I): GetHostResponse {
    const message = createBaseGetHostResponse();
    message.success = object.success ?? false;
    message.host = object.host ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

export type AgentService = typeof AgentService;
export const AgentService = {
  healthCheck: {
    path: "/agent.Agent/HealthCheck",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: HealthCheckRequest) => Buffer.from(HealthCheckRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => HealthCheckRequest.decode(value),
    responseSerialize: (value: HealthCheckResponse) => Buffer.from(HealthCheckResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => HealthCheckResponse.decode(value),
  },
  metrics: {
    path: "/agent.Agent/Metrics",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: MetricsRequest) => Buffer.from(MetricsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => MetricsRequest.decode(value),
    responseSerialize: (value: MetricsResponse) => Buffer.from(MetricsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => MetricsResponse.decode(value),
  },
  getHost: {
    path: "/agent.Agent/GetHost",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetHostRequest) => Buffer.from(GetHostRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetHostRequest.decode(value),
    responseSerialize: (value: GetHostResponse) => Buffer.from(GetHostResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetHostResponse.decode(value),
  },
} as const;

export interface AgentServer extends UntypedServiceImplementation {
  healthCheck: handleUnaryCall<HealthCheckRequest, HealthCheckResponse>;
  metrics: handleUnaryCall<MetricsRequest, MetricsResponse>;
  getHost: handleUnaryCall<GetHostRequest, GetHostResponse>;
}

export interface AgentClient extends Client {
  healthCheck(
    request: HealthCheckRequest,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  healthCheck(
    request: HealthCheckRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: HealthCheckResponse) => void,
  ): ClientUnaryCall;
  metrics(
    request: MetricsRequest,
    callback: (error: ServiceError | null, response: MetricsResponse) => void,
  ): ClientUnaryCall;
  metrics(
    request: MetricsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: MetricsResponse) => void,
  ): ClientUnaryCall;
  metrics(
    request: MetricsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: MetricsResponse) => void,
  ): ClientUnaryCall;
  getHost(
    request: GetHostRequest,
    callback: (error: ServiceError | null, response: GetHostResponse) => void,
  ): ClientUnaryCall;
  getHost(
    request: GetHostRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetHostResponse) => void,
  ): ClientUnaryCall;
  getHost(
    request: GetHostRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetHostResponse) => void,
  ): ClientUnaryCall;
}

export const AgentClient = makeGenericClientConstructor(AgentService, "agent.Agent") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): AgentClient;
  service: typeof AgentService;
  serviceName: string;
};

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
