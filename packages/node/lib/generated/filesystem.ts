// Code generated by protoc-gen-ts_proto. DO NOT EDIT.
// versions:
//   protoc-gen-ts_proto  v2.7.0
//   protoc               v5.29.3
// source: filesystem.proto

/* eslint-disable */
import { BinaryReader, BinaryWriter } from "@bufbuild/protobuf/wire";
import {
  type CallOptions,
  ChannelCredentials,
  Client,
  type ClientOptions,
  type ClientReadableStream,
  type ClientUnaryCall,
  type ClientWritableStream,
  type handleClientStreamingCall,
  type handleServerStreamingCall,
  type handleUnaryCall,
  makeGenericClientConstructor,
  Metadata,
  type ServiceError,
  type UntypedServiceImplementation,
} from "@grpc/grpc-js";

export const protobufPackage = "filesystem";

export interface ReadFileRequest {
  path: string;
  format: string;
}

export interface ReadFileResponse {
  success: boolean;
  content: string;
  binary: Buffer;
  error: string;
}

export interface ReadFileStreamRequest {
  path: string;
}

export interface FileChunk {
  path: string;
  content: Buffer;
  end: boolean;
  error: string;
}

export interface WriteFileRequest {
  path: string;
  format: string;
  content: string;
  binary: Buffer;
}

export interface WriteFileResponse {
  success: boolean;
  error: string;
}

export interface ReadDirectoryRequest {
  path: string;
}

export interface ReadDirectoryResponse {
  success: boolean;
  files: string[];
  error: string;
}

export interface CreateDirectoryRequest {
  path: string;
}

export interface CreateDirectoryResponse {
  success: boolean;
  error: string;
}

export interface RenameRequest {
  oldPath: string;
  newPath: string;
}

export interface RenameResponse {
  success: boolean;
  error: string;
}

export interface UnlinkRequest {
  path: string;
}

export interface UnlinkResponse {
  success: boolean;
  error: string;
}

export interface ExistsRequest {
  path: string;
}

export interface ExistsResponse {
  success: boolean;
  exists: boolean;
  error: string;
}

export interface GetStatsRequest {
  path: string;
}

export interface GetStatsResponse {
  success: boolean;
  isDirectory: boolean;
  isFile: boolean;
  size: number;
  modifiedTime: string;
  error: string;
}

export interface WatchRequest {
  path: string;
  recursive?: boolean | undefined;
  events?: number | undefined;
}

export interface WatchEvent {
  path: string;
  type: string;
  oldPath: string;
  isDirectory: boolean;
  error: string;
}

function createBaseReadFileRequest(): ReadFileRequest {
  return { path: "", format: "" };
}

export const ReadFileRequest: MessageFns<ReadFileRequest> = {
  encode(message: ReadFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFileRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
    };
  },

  toJSON(message: ReadFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFileRequest>, I>>(base?: I): ReadFileRequest {
    return ReadFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFileRequest>, I>>(object: I): ReadFileRequest {
    const message = createBaseReadFileRequest();
    message.path = object.path ?? "";
    message.format = object.format ?? "";
    return message;
  },
};

function createBaseReadFileResponse(): ReadFileResponse {
  return { success: false, content: "", binary: Buffer.alloc(0), error: "" };
}

export const ReadFileResponse: MessageFns<ReadFileResponse> = {
  encode(message: ReadFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.content !== "") {
      writer.uint32(18).string(message.content);
    }
    if (message.binary.length !== 0) {
      writer.uint32(26).bytes(message.binary);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.binary = Buffer.from(reader.bytes());
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFileResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      binary: isSet(object.binary) ? Buffer.from(bytesFromBase64(object.binary)) : Buffer.alloc(0),
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ReadFileResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFileResponse>, I>>(base?: I): ReadFileResponse {
    return ReadFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFileResponse>, I>>(object: I): ReadFileResponse {
    const message = createBaseReadFileResponse();
    message.success = object.success ?? false;
    message.content = object.content ?? "";
    message.binary = object.binary ?? Buffer.alloc(0);
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseReadFileStreamRequest(): ReadFileStreamRequest {
  return { path: "" };
}

export const ReadFileStreamRequest: MessageFns<ReadFileStreamRequest> = {
  encode(message: ReadFileStreamRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadFileStreamRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadFileStreamRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadFileStreamRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ReadFileStreamRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadFileStreamRequest>, I>>(base?: I): ReadFileStreamRequest {
    return ReadFileStreamRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadFileStreamRequest>, I>>(object: I): ReadFileStreamRequest {
    const message = createBaseReadFileStreamRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseFileChunk(): FileChunk {
  return { path: "", content: Buffer.alloc(0), end: false, error: "" };
}

export const FileChunk: MessageFns<FileChunk> = {
  encode(message: FileChunk, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.content.length !== 0) {
      writer.uint32(18).bytes(message.content);
    }
    if (message.end !== false) {
      writer.uint32(24).bool(message.end);
    }
    if (message.error !== "") {
      writer.uint32(34).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): FileChunk {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseFileChunk();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.content = Buffer.from(reader.bytes());
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.end = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): FileChunk {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      content: isSet(object.content) ? Buffer.from(bytesFromBase64(object.content)) : Buffer.alloc(0),
      end: isSet(object.end) ? globalThis.Boolean(object.end) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: FileChunk): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.content.length !== 0) {
      obj.content = base64FromBytes(message.content);
    }
    if (message.end !== false) {
      obj.end = message.end;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<FileChunk>, I>>(base?: I): FileChunk {
    return FileChunk.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<FileChunk>, I>>(object: I): FileChunk {
    const message = createBaseFileChunk();
    message.path = object.path ?? "";
    message.content = object.content ?? Buffer.alloc(0);
    message.end = object.end ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseWriteFileRequest(): WriteFileRequest {
  return { path: "", format: "", content: "", binary: Buffer.alloc(0) };
}

export const WriteFileRequest: MessageFns<WriteFileRequest> = {
  encode(message: WriteFileRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.format !== "") {
      writer.uint32(18).string(message.format);
    }
    if (message.content !== "") {
      writer.uint32(26).string(message.content);
    }
    if (message.binary.length !== 0) {
      writer.uint32(34).bytes(message.binary);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFileRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFileRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.format = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.content = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 34) {
            break;
          }

          message.binary = Buffer.from(reader.bytes());
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFileRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      format: isSet(object.format) ? globalThis.String(object.format) : "",
      content: isSet(object.content) ? globalThis.String(object.content) : "",
      binary: isSet(object.binary) ? Buffer.from(bytesFromBase64(object.binary)) : Buffer.alloc(0),
    };
  },

  toJSON(message: WriteFileRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.format !== "") {
      obj.format = message.format;
    }
    if (message.content !== "") {
      obj.content = message.content;
    }
    if (message.binary.length !== 0) {
      obj.binary = base64FromBytes(message.binary);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFileRequest>, I>>(base?: I): WriteFileRequest {
    return WriteFileRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFileRequest>, I>>(object: I): WriteFileRequest {
    const message = createBaseWriteFileRequest();
    message.path = object.path ?? "";
    message.format = object.format ?? "";
    message.content = object.content ?? "";
    message.binary = object.binary ?? Buffer.alloc(0);
    return message;
  },
};

function createBaseWriteFileResponse(): WriteFileResponse {
  return { success: false, error: "" };
}

export const WriteFileResponse: MessageFns<WriteFileResponse> = {
  encode(message: WriteFileResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WriteFileResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWriteFileResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WriteFileResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: WriteFileResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WriteFileResponse>, I>>(base?: I): WriteFileResponse {
    return WriteFileResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WriteFileResponse>, I>>(object: I): WriteFileResponse {
    const message = createBaseWriteFileResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseReadDirectoryRequest(): ReadDirectoryRequest {
  return { path: "" };
}

export const ReadDirectoryRequest: MessageFns<ReadDirectoryRequest> = {
  encode(message: ReadDirectoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadDirectoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadDirectoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadDirectoryRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ReadDirectoryRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadDirectoryRequest>, I>>(base?: I): ReadDirectoryRequest {
    return ReadDirectoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadDirectoryRequest>, I>>(object: I): ReadDirectoryRequest {
    const message = createBaseReadDirectoryRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseReadDirectoryResponse(): ReadDirectoryResponse {
  return { success: false, files: [], error: "" };
}

export const ReadDirectoryResponse: MessageFns<ReadDirectoryResponse> = {
  encode(message: ReadDirectoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    for (const v of message.files) {
      writer.uint32(18).string(v!);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ReadDirectoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseReadDirectoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.files.push(reader.string());
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ReadDirectoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      files: globalThis.Array.isArray(object?.files) ? object.files.map((e: any) => globalThis.String(e)) : [],
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ReadDirectoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.files?.length) {
      obj.files = message.files;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ReadDirectoryResponse>, I>>(base?: I): ReadDirectoryResponse {
    return ReadDirectoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ReadDirectoryResponse>, I>>(object: I): ReadDirectoryResponse {
    const message = createBaseReadDirectoryResponse();
    message.success = object.success ?? false;
    message.files = object.files?.map((e) => e) || [];
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseCreateDirectoryRequest(): CreateDirectoryRequest {
  return { path: "" };
}

export const CreateDirectoryRequest: MessageFns<CreateDirectoryRequest> = {
  encode(message: CreateDirectoryRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDirectoryRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDirectoryRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDirectoryRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: CreateDirectoryRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDirectoryRequest>, I>>(base?: I): CreateDirectoryRequest {
    return CreateDirectoryRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDirectoryRequest>, I>>(object: I): CreateDirectoryRequest {
    const message = createBaseCreateDirectoryRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseCreateDirectoryResponse(): CreateDirectoryResponse {
  return { success: false, error: "" };
}

export const CreateDirectoryResponse: MessageFns<CreateDirectoryResponse> = {
  encode(message: CreateDirectoryResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): CreateDirectoryResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseCreateDirectoryResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): CreateDirectoryResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: CreateDirectoryResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<CreateDirectoryResponse>, I>>(base?: I): CreateDirectoryResponse {
    return CreateDirectoryResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<CreateDirectoryResponse>, I>>(object: I): CreateDirectoryResponse {
    const message = createBaseCreateDirectoryResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseRenameRequest(): RenameRequest {
  return { oldPath: "", newPath: "" };
}

export const RenameRequest: MessageFns<RenameRequest> = {
  encode(message: RenameRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.oldPath !== "") {
      writer.uint32(10).string(message.oldPath);
    }
    if (message.newPath !== "") {
      writer.uint32(18).string(message.newPath);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.oldPath = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.newPath = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameRequest {
    return {
      oldPath: isSet(object.oldPath) ? globalThis.String(object.oldPath) : "",
      newPath: isSet(object.newPath) ? globalThis.String(object.newPath) : "",
    };
  },

  toJSON(message: RenameRequest): unknown {
    const obj: any = {};
    if (message.oldPath !== "") {
      obj.oldPath = message.oldPath;
    }
    if (message.newPath !== "") {
      obj.newPath = message.newPath;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenameRequest>, I>>(base?: I): RenameRequest {
    return RenameRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenameRequest>, I>>(object: I): RenameRequest {
    const message = createBaseRenameRequest();
    message.oldPath = object.oldPath ?? "";
    message.newPath = object.newPath ?? "";
    return message;
  },
};

function createBaseRenameResponse(): RenameResponse {
  return { success: false, error: "" };
}

export const RenameResponse: MessageFns<RenameResponse> = {
  encode(message: RenameResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): RenameResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseRenameResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): RenameResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: RenameResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<RenameResponse>, I>>(base?: I): RenameResponse {
    return RenameResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<RenameResponse>, I>>(object: I): RenameResponse {
    const message = createBaseRenameResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseUnlinkRequest(): UnlinkRequest {
  return { path: "" };
}

export const UnlinkRequest: MessageFns<UnlinkRequest> = {
  encode(message: UnlinkRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlinkRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlinkRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlinkRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: UnlinkRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlinkRequest>, I>>(base?: I): UnlinkRequest {
    return UnlinkRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlinkRequest>, I>>(object: I): UnlinkRequest {
    const message = createBaseUnlinkRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseUnlinkResponse(): UnlinkResponse {
  return { success: false, error: "" };
}

export const UnlinkResponse: MessageFns<UnlinkResponse> = {
  encode(message: UnlinkResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.error !== "") {
      writer.uint32(18).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): UnlinkResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseUnlinkResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): UnlinkResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: UnlinkResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<UnlinkResponse>, I>>(base?: I): UnlinkResponse {
    return UnlinkResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<UnlinkResponse>, I>>(object: I): UnlinkResponse {
    const message = createBaseUnlinkResponse();
    message.success = object.success ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseExistsRequest(): ExistsRequest {
  return { path: "" };
}

export const ExistsRequest: MessageFns<ExistsRequest> = {
  encode(message: ExistsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExistsRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: ExistsRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExistsRequest>, I>>(base?: I): ExistsRequest {
    return ExistsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExistsRequest>, I>>(object: I): ExistsRequest {
    const message = createBaseExistsRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseExistsResponse(): ExistsResponse {
  return { success: false, exists: false, error: "" };
}

export const ExistsResponse: MessageFns<ExistsResponse> = {
  encode(message: ExistsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.exists !== false) {
      writer.uint32(16).bool(message.exists);
    }
    if (message.error !== "") {
      writer.uint32(26).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): ExistsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseExistsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.exists = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): ExistsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      exists: isSet(object.exists) ? globalThis.Boolean(object.exists) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: ExistsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.exists !== false) {
      obj.exists = message.exists;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<ExistsResponse>, I>>(base?: I): ExistsResponse {
    return ExistsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<ExistsResponse>, I>>(object: I): ExistsResponse {
    const message = createBaseExistsResponse();
    message.success = object.success ?? false;
    message.exists = object.exists ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseGetStatsRequest(): GetStatsRequest {
  return { path: "" };
}

export const GetStatsRequest: MessageFns<GetStatsRequest> = {
  encode(message: GetStatsRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatsRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatsRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatsRequest {
    return { path: isSet(object.path) ? globalThis.String(object.path) : "" };
  },

  toJSON(message: GetStatsRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatsRequest>, I>>(base?: I): GetStatsRequest {
    return GetStatsRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatsRequest>, I>>(object: I): GetStatsRequest {
    const message = createBaseGetStatsRequest();
    message.path = object.path ?? "";
    return message;
  },
};

function createBaseGetStatsResponse(): GetStatsResponse {
  return { success: false, isDirectory: false, isFile: false, size: 0, modifiedTime: "", error: "" };
}

export const GetStatsResponse: MessageFns<GetStatsResponse> = {
  encode(message: GetStatsResponse, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.success !== false) {
      writer.uint32(8).bool(message.success);
    }
    if (message.isDirectory !== false) {
      writer.uint32(16).bool(message.isDirectory);
    }
    if (message.isFile !== false) {
      writer.uint32(24).bool(message.isFile);
    }
    if (message.size !== 0) {
      writer.uint32(32).int64(message.size);
    }
    if (message.modifiedTime !== "") {
      writer.uint32(42).string(message.modifiedTime);
    }
    if (message.error !== "") {
      writer.uint32(50).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): GetStatsResponse {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseGetStatsResponse();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 8) {
            break;
          }

          message.success = reader.bool();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.isDirectory = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.isFile = reader.bool();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.size = longToNumber(reader.int64());
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.modifiedTime = reader.string();
          continue;
        }
        case 6: {
          if (tag !== 50) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): GetStatsResponse {
    return {
      success: isSet(object.success) ? globalThis.Boolean(object.success) : false,
      isDirectory: isSet(object.isDirectory) ? globalThis.Boolean(object.isDirectory) : false,
      isFile: isSet(object.isFile) ? globalThis.Boolean(object.isFile) : false,
      size: isSet(object.size) ? globalThis.Number(object.size) : 0,
      modifiedTime: isSet(object.modifiedTime) ? globalThis.String(object.modifiedTime) : "",
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: GetStatsResponse): unknown {
    const obj: any = {};
    if (message.success !== false) {
      obj.success = message.success;
    }
    if (message.isDirectory !== false) {
      obj.isDirectory = message.isDirectory;
    }
    if (message.isFile !== false) {
      obj.isFile = message.isFile;
    }
    if (message.size !== 0) {
      obj.size = Math.round(message.size);
    }
    if (message.modifiedTime !== "") {
      obj.modifiedTime = message.modifiedTime;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<GetStatsResponse>, I>>(base?: I): GetStatsResponse {
    return GetStatsResponse.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<GetStatsResponse>, I>>(object: I): GetStatsResponse {
    const message = createBaseGetStatsResponse();
    message.success = object.success ?? false;
    message.isDirectory = object.isDirectory ?? false;
    message.isFile = object.isFile ?? false;
    message.size = object.size ?? 0;
    message.modifiedTime = object.modifiedTime ?? "";
    message.error = object.error ?? "";
    return message;
  },
};

function createBaseWatchRequest(): WatchRequest {
  return { path: "", recursive: undefined, events: undefined };
}

export const WatchRequest: MessageFns<WatchRequest> = {
  encode(message: WatchRequest, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.recursive !== undefined) {
      writer.uint32(16).bool(message.recursive);
    }
    if (message.events !== undefined) {
      writer.uint32(24).uint32(message.events);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WatchRequest {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchRequest();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 16) {
            break;
          }

          message.recursive = reader.bool();
          continue;
        }
        case 3: {
          if (tag !== 24) {
            break;
          }

          message.events = reader.uint32();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchRequest {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      recursive: isSet(object.recursive) ? globalThis.Boolean(object.recursive) : undefined,
      events: isSet(object.events) ? globalThis.Number(object.events) : undefined,
    };
  },

  toJSON(message: WatchRequest): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.recursive !== undefined) {
      obj.recursive = message.recursive;
    }
    if (message.events !== undefined) {
      obj.events = Math.round(message.events);
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchRequest>, I>>(base?: I): WatchRequest {
    return WatchRequest.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchRequest>, I>>(object: I): WatchRequest {
    const message = createBaseWatchRequest();
    message.path = object.path ?? "";
    message.recursive = object.recursive ?? undefined;
    message.events = object.events ?? undefined;
    return message;
  },
};

function createBaseWatchEvent(): WatchEvent {
  return { path: "", type: "", oldPath: "", isDirectory: false, error: "" };
}

export const WatchEvent: MessageFns<WatchEvent> = {
  encode(message: WatchEvent, writer: BinaryWriter = new BinaryWriter()): BinaryWriter {
    if (message.path !== "") {
      writer.uint32(10).string(message.path);
    }
    if (message.type !== "") {
      writer.uint32(18).string(message.type);
    }
    if (message.oldPath !== "") {
      writer.uint32(26).string(message.oldPath);
    }
    if (message.isDirectory !== false) {
      writer.uint32(32).bool(message.isDirectory);
    }
    if (message.error !== "") {
      writer.uint32(42).string(message.error);
    }
    return writer;
  },

  decode(input: BinaryReader | Uint8Array, length?: number): WatchEvent {
    const reader = input instanceof BinaryReader ? input : new BinaryReader(input);
    let end = length === undefined ? reader.len : reader.pos + length;
    const message = createBaseWatchEvent();
    while (reader.pos < end) {
      const tag = reader.uint32();
      switch (tag >>> 3) {
        case 1: {
          if (tag !== 10) {
            break;
          }

          message.path = reader.string();
          continue;
        }
        case 2: {
          if (tag !== 18) {
            break;
          }

          message.type = reader.string();
          continue;
        }
        case 3: {
          if (tag !== 26) {
            break;
          }

          message.oldPath = reader.string();
          continue;
        }
        case 4: {
          if (tag !== 32) {
            break;
          }

          message.isDirectory = reader.bool();
          continue;
        }
        case 5: {
          if (tag !== 42) {
            break;
          }

          message.error = reader.string();
          continue;
        }
      }
      if ((tag & 7) === 4 || tag === 0) {
        break;
      }
      reader.skip(tag & 7);
    }
    return message;
  },

  fromJSON(object: any): WatchEvent {
    return {
      path: isSet(object.path) ? globalThis.String(object.path) : "",
      type: isSet(object.type) ? globalThis.String(object.type) : "",
      oldPath: isSet(object.oldPath) ? globalThis.String(object.oldPath) : "",
      isDirectory: isSet(object.isDirectory) ? globalThis.Boolean(object.isDirectory) : false,
      error: isSet(object.error) ? globalThis.String(object.error) : "",
    };
  },

  toJSON(message: WatchEvent): unknown {
    const obj: any = {};
    if (message.path !== "") {
      obj.path = message.path;
    }
    if (message.type !== "") {
      obj.type = message.type;
    }
    if (message.oldPath !== "") {
      obj.oldPath = message.oldPath;
    }
    if (message.isDirectory !== false) {
      obj.isDirectory = message.isDirectory;
    }
    if (message.error !== "") {
      obj.error = message.error;
    }
    return obj;
  },

  create<I extends Exact<DeepPartial<WatchEvent>, I>>(base?: I): WatchEvent {
    return WatchEvent.fromPartial(base ?? ({} as any));
  },
  fromPartial<I extends Exact<DeepPartial<WatchEvent>, I>>(object: I): WatchEvent {
    const message = createBaseWatchEvent();
    message.path = object.path ?? "";
    message.type = object.type ?? "";
    message.oldPath = object.oldPath ?? "";
    message.isDirectory = object.isDirectory ?? false;
    message.error = object.error ?? "";
    return message;
  },
};

export type FilesystemService = typeof FilesystemService;
export const FilesystemService = {
  readFile: {
    path: "/filesystem.Filesystem/ReadFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReadFileRequest) => Buffer.from(ReadFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReadFileRequest.decode(value),
    responseSerialize: (value: ReadFileResponse) => Buffer.from(ReadFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReadFileResponse.decode(value),
  },
  readFileStream: {
    path: "/filesystem.Filesystem/ReadFileStream",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: ReadFileStreamRequest) => Buffer.from(ReadFileStreamRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReadFileStreamRequest.decode(value),
    responseSerialize: (value: FileChunk) => Buffer.from(FileChunk.encode(value).finish()),
    responseDeserialize: (value: Buffer) => FileChunk.decode(value),
  },
  writeFile: {
    path: "/filesystem.Filesystem/WriteFile",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: WriteFileRequest) => Buffer.from(WriteFileRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WriteFileRequest.decode(value),
    responseSerialize: (value: WriteFileResponse) => Buffer.from(WriteFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WriteFileResponse.decode(value),
  },
  writeFileStream: {
    path: "/filesystem.Filesystem/WriteFileStream",
    requestStream: true,
    responseStream: false,
    requestSerialize: (value: FileChunk) => Buffer.from(FileChunk.encode(value).finish()),
    requestDeserialize: (value: Buffer) => FileChunk.decode(value),
    responseSerialize: (value: WriteFileResponse) => Buffer.from(WriteFileResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WriteFileResponse.decode(value),
  },
  readDirectory: {
    path: "/filesystem.Filesystem/ReadDirectory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ReadDirectoryRequest) => Buffer.from(ReadDirectoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ReadDirectoryRequest.decode(value),
    responseSerialize: (value: ReadDirectoryResponse) => Buffer.from(ReadDirectoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ReadDirectoryResponse.decode(value),
  },
  createDirectory: {
    path: "/filesystem.Filesystem/CreateDirectory",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: CreateDirectoryRequest) => Buffer.from(CreateDirectoryRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => CreateDirectoryRequest.decode(value),
    responseSerialize: (value: CreateDirectoryResponse) => Buffer.from(CreateDirectoryResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => CreateDirectoryResponse.decode(value),
  },
  rename: {
    path: "/filesystem.Filesystem/Rename",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: RenameRequest) => Buffer.from(RenameRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => RenameRequest.decode(value),
    responseSerialize: (value: RenameResponse) => Buffer.from(RenameResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => RenameResponse.decode(value),
  },
  unlink: {
    path: "/filesystem.Filesystem/Unlink",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: UnlinkRequest) => Buffer.from(UnlinkRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => UnlinkRequest.decode(value),
    responseSerialize: (value: UnlinkResponse) => Buffer.from(UnlinkResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => UnlinkResponse.decode(value),
  },
  exists: {
    path: "/filesystem.Filesystem/Exists",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: ExistsRequest) => Buffer.from(ExistsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => ExistsRequest.decode(value),
    responseSerialize: (value: ExistsResponse) => Buffer.from(ExistsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => ExistsResponse.decode(value),
  },
  getStats: {
    path: "/filesystem.Filesystem/GetStats",
    requestStream: false,
    responseStream: false,
    requestSerialize: (value: GetStatsRequest) => Buffer.from(GetStatsRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => GetStatsRequest.decode(value),
    responseSerialize: (value: GetStatsResponse) => Buffer.from(GetStatsResponse.encode(value).finish()),
    responseDeserialize: (value: Buffer) => GetStatsResponse.decode(value),
  },
  watch: {
    path: "/filesystem.Filesystem/Watch",
    requestStream: false,
    responseStream: true,
    requestSerialize: (value: WatchRequest) => Buffer.from(WatchRequest.encode(value).finish()),
    requestDeserialize: (value: Buffer) => WatchRequest.decode(value),
    responseSerialize: (value: WatchEvent) => Buffer.from(WatchEvent.encode(value).finish()),
    responseDeserialize: (value: Buffer) => WatchEvent.decode(value),
  },
} as const;

export interface FilesystemServer extends UntypedServiceImplementation {
  readFile: handleUnaryCall<ReadFileRequest, ReadFileResponse>;
  readFileStream: handleServerStreamingCall<ReadFileStreamRequest, FileChunk>;
  writeFile: handleUnaryCall<WriteFileRequest, WriteFileResponse>;
  writeFileStream: handleClientStreamingCall<FileChunk, WriteFileResponse>;
  readDirectory: handleUnaryCall<ReadDirectoryRequest, ReadDirectoryResponse>;
  createDirectory: handleUnaryCall<CreateDirectoryRequest, CreateDirectoryResponse>;
  rename: handleUnaryCall<RenameRequest, RenameResponse>;
  unlink: handleUnaryCall<UnlinkRequest, UnlinkResponse>;
  exists: handleUnaryCall<ExistsRequest, ExistsResponse>;
  getStats: handleUnaryCall<GetStatsRequest, GetStatsResponse>;
  watch: handleServerStreamingCall<WatchRequest, WatchEvent>;
}

export interface FilesystemClient extends Client {
  readFile(
    request: ReadFileRequest,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  readFile(
    request: ReadFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  readFile(
    request: ReadFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReadFileResponse) => void,
  ): ClientUnaryCall;
  readFileStream(request: ReadFileStreamRequest, options?: Partial<CallOptions>): ClientReadableStream<FileChunk>;
  readFileStream(
    request: ReadFileStreamRequest,
    metadata?: Metadata,
    options?: Partial<CallOptions>,
  ): ClientReadableStream<FileChunk>;
  writeFile(
    request: WriteFileRequest,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientUnaryCall;
  writeFile(
    request: WriteFileRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientUnaryCall;
  writeFile(
    request: WriteFileRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientUnaryCall;
  writeFileStream(
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientWritableStream<FileChunk>;
  writeFileStream(
    metadata: Metadata,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientWritableStream<FileChunk>;
  writeFileStream(
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientWritableStream<FileChunk>;
  writeFileStream(
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: WriteFileResponse) => void,
  ): ClientWritableStream<FileChunk>;
  readDirectory(
    request: ReadDirectoryRequest,
    callback: (error: ServiceError | null, response: ReadDirectoryResponse) => void,
  ): ClientUnaryCall;
  readDirectory(
    request: ReadDirectoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ReadDirectoryResponse) => void,
  ): ClientUnaryCall;
  readDirectory(
    request: ReadDirectoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ReadDirectoryResponse) => void,
  ): ClientUnaryCall;
  createDirectory(
    request: CreateDirectoryRequest,
    callback: (error: ServiceError | null, response: CreateDirectoryResponse) => void,
  ): ClientUnaryCall;
  createDirectory(
    request: CreateDirectoryRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: CreateDirectoryResponse) => void,
  ): ClientUnaryCall;
  createDirectory(
    request: CreateDirectoryRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: CreateDirectoryResponse) => void,
  ): ClientUnaryCall;
  rename(
    request: RenameRequest,
    callback: (error: ServiceError | null, response: RenameResponse) => void,
  ): ClientUnaryCall;
  rename(
    request: RenameRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: RenameResponse) => void,
  ): ClientUnaryCall;
  rename(
    request: RenameRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: RenameResponse) => void,
  ): ClientUnaryCall;
  unlink(
    request: UnlinkRequest,
    callback: (error: ServiceError | null, response: UnlinkResponse) => void,
  ): ClientUnaryCall;
  unlink(
    request: UnlinkRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: UnlinkResponse) => void,
  ): ClientUnaryCall;
  unlink(
    request: UnlinkRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: UnlinkResponse) => void,
  ): ClientUnaryCall;
  exists(
    request: ExistsRequest,
    callback: (error: ServiceError | null, response: ExistsResponse) => void,
  ): ClientUnaryCall;
  exists(
    request: ExistsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: ExistsResponse) => void,
  ): ClientUnaryCall;
  exists(
    request: ExistsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: ExistsResponse) => void,
  ): ClientUnaryCall;
  getStats(
    request: GetStatsRequest,
    callback: (error: ServiceError | null, response: GetStatsResponse) => void,
  ): ClientUnaryCall;
  getStats(
    request: GetStatsRequest,
    metadata: Metadata,
    callback: (error: ServiceError | null, response: GetStatsResponse) => void,
  ): ClientUnaryCall;
  getStats(
    request: GetStatsRequest,
    metadata: Metadata,
    options: Partial<CallOptions>,
    callback: (error: ServiceError | null, response: GetStatsResponse) => void,
  ): ClientUnaryCall;
  watch(request: WatchRequest, options?: Partial<CallOptions>): ClientReadableStream<WatchEvent>;
  watch(request: WatchRequest, metadata?: Metadata, options?: Partial<CallOptions>): ClientReadableStream<WatchEvent>;
}

export const FilesystemClient = makeGenericClientConstructor(FilesystemService, "filesystem.Filesystem") as unknown as {
  new (address: string, credentials: ChannelCredentials, options?: Partial<ClientOptions>): FilesystemClient;
  service: typeof FilesystemService;
  serviceName: string;
};

function bytesFromBase64(b64: string): Uint8Array {
  return Uint8Array.from(globalThis.Buffer.from(b64, "base64"));
}

function base64FromBytes(arr: Uint8Array): string {
  return globalThis.Buffer.from(arr).toString("base64");
}

type Builtin = Date | Function | Uint8Array | string | number | boolean | undefined;

export type DeepPartial<T> = T extends Builtin ? T
  : T extends globalThis.Array<infer U> ? globalThis.Array<DeepPartial<U>>
  : T extends ReadonlyArray<infer U> ? ReadonlyArray<DeepPartial<U>>
  : T extends {} ? { [K in keyof T]?: DeepPartial<T[K]> }
  : Partial<T>;

type KeysOfUnion<T> = T extends T ? keyof T : never;
export type Exact<P, I extends P> = P extends Builtin ? P
  : P & { [K in keyof P]: Exact<P[K], I[K]> } & { [K in Exclude<keyof I, KeysOfUnion<P>>]: never };

function longToNumber(int64: { toString(): string }): number {
  const num = globalThis.Number(int64.toString());
  if (num > globalThis.Number.MAX_SAFE_INTEGER) {
    throw new globalThis.Error("Value is larger than Number.MAX_SAFE_INTEGER");
  }
  if (num < globalThis.Number.MIN_SAFE_INTEGER) {
    throw new globalThis.Error("Value is smaller than Number.MIN_SAFE_INTEGER");
  }
  return num;
}

function isSet(value: any): boolean {
  return value !== null && value !== undefined;
}

export interface MessageFns<T> {
  encode(message: T, writer?: BinaryWriter): BinaryWriter;
  decode(input: BinaryReader | Uint8Array, length?: number): T;
  fromJSON(object: any): T;
  toJSON(message: T): unknown;
  create<I extends Exact<DeepPartial<T>, I>>(base?: I): T;
  fromPartial<I extends Exact<DeepPartial<T>, I>>(object: I): T;
}
